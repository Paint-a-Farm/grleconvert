use std::env;
use std::fs::File;
use std::io::{BufReader, BufWriter, Read};
use std::path::Path;

fn read_u16_le(data: &[u8], offset: usize) -> u16 {
    u16::from_le_bytes([data[offset], data[offset + 1]])
}

fn read_u32_le(data: &[u8], offset: usize) -> u32 {
    u32::from_le_bytes([data[offset], data[offset + 1], data[offset + 2], data[offset + 3]])
}

fn decode_grle_rle(data: &[u8], expected_size: usize) -> Vec<u8> {
    let mut output = Vec::with_capacity(expected_size);
    let mut i = 1; // Skip first byte (0x00 flag/padding)

    // RLE format: read pairs (prev, new)
    // - If prev == new: read extended count, emit count pixels of that value
    //   - Count: each 0xff byte adds 255, final non-0xff byte is remainder, +2 offset
    // - If prev != new: emit 1 pixel of prev, then back up to re-read new as next prev
    while i + 1 < data.len() && output.len() < expected_size {
        let prev = data[i];
        let new_val = data[i + 1];
        i += 2;

        if prev == new_val {
            // Same value: read extended count with 0xff
            let mut count = 0usize;
            while i < data.len() && data[i] == 0xff {
                count += 255;
                i += 1;
            }
            if i < data.len() {
                count += data[i] as usize;
                i += 1;
            }
            count += 2; // Counts are offset by 2

            // Emit pixels
            let to_emit = count.min(expected_size - output.len());
            output.extend(std::iter::repeat(new_val).take(to_emit));
        } else {
            // Transition: emit 1 pixel of prev, back up to re-read new as next prev
            output.push(prev);
            i -= 1; // Back up so new_val becomes next prev
        }
    }

    // Pad with zeros if needed (shouldn't happen with valid files)
    output.resize(expected_size, 0);
    output
}

fn convert_grle(input_path: &str, output_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut file = BufReader::new(File::open(input_path)?);
    let mut data = Vec::new();
    file.read_to_end(&mut data)?;

    // Check magic
    if &data[0..4] != b"GRLE" {
        return Err("Not a valid GRLE file".into());
    }

    let version = read_u16_le(&data, 4);
    // Width and height stored as size/256 in u16 with 2 byte padding between
    let width = (read_u16_le(&data, 6) as usize) * 256;
    let height = (read_u16_le(&data, 10) as usize) * 256;
    // GRLE files always have 1 channel (grayscale)
    let channels = 1usize;
    let _compressed_size = read_u32_le(&data, 16);

    println!("GRLE version: {}", version);
    println!("Size: {}x{}", width, height);
    println!("Channels: {}", channels);

    // Data starts at offset 20
    let compressed_data = &data[20..];
    let expected_size = width * height * channels;

    let pixels = decode_grle_rle(compressed_data, expected_size);

    // Write PNG with GIANTS-compatible settings
    let file = File::create(output_path)?;
    let w = BufWriter::new(file);

    let mut encoder = png::Encoder::new(w, width as u32, height as u32);
    encoder.set_color(png::ColorType::Grayscale);
    encoder.set_depth(png::BitDepth::Eight);
    encoder.set_compression(png::Compression::Default);

    // Add GIANTS-compatible text chunks
    encoder.add_text_chunk("Generated by".to_string(), "GIANTS".to_string())?;
    encoder.add_text_chunk("Author's name".to_string(), "GIANTS Software GmbH".to_string())?;
    encoder.add_text_chunk("Author's comments".to_string(), "GIANTS Engine".to_string())?;

    let mut writer = encoder.write_header()?;
    writer.write_image_data(&pixels)?;

    println!("Saved to {}", output_path);
    Ok(())
}

fn convert_gdm(input_path: &str, output_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut file = BufReader::new(File::open(input_path)?);
    let mut data = Vec::new();
    file.read_to_end(&mut data)?;

    // Check magic - "MDF or !MDF
    if data.len() < 16 {
        return Err("File too small".into());
    }
    if &data[0..4] != &[0x22, 0x4d, 0x44, 0x46] && &data[0..4] != &[0x21, 0x4d, 0x44, 0x46] {
        return Err("Not a valid GDM file".into());
    }

    // Parse header
    let dimension = if data[8] == 0x07 { 4096usize } else { 2048usize };
    let channels = data[11] as u32;

    println!("GDM: {}x{}, {} channels", dimension, dimension, channels);

    let chunk_size = 32usize;
    let chunks_per_row = dimension / chunk_size;
    let total_chunks = chunks_per_row * chunks_per_row;

    let chunk_table_start = 16usize;
    let table_size = total_chunks * 4;
    let data_start = chunk_table_start + table_size;

    if data.len() < data_start {
        return Err("File too small for chunk table".into());
    }

    let chunk_data = &data[data_start..];
    println!("Data section: {} bytes", chunk_data.len());

    // Create output image
    let mut pixels = vec![0u8; dimension * dimension];
    let mut data_pos = 0usize;

    // Decode chunks - for each chunk with table!=0, read 128 bytes of bitmask data
    for chunk_idx in 0..total_chunks {
        let chunk_val = read_u32_le(&data, chunk_table_start + chunk_idx * 4);

        if chunk_val == 0 {
            continue;
        }

        let chunk_row = chunk_idx / chunks_per_row;
        let chunk_col = chunk_idx % chunks_per_row;
        let start_y = chunk_row * chunk_size;
        let start_x = chunk_col * chunk_size;

        // Read 32 rows of bitmask data (4 bytes each)
        for row in 0..32 {
            if data_pos + 4 > chunk_data.len() {
                break;
            }

            let row_mask = read_u32_le(chunk_data, data_pos);
            data_pos += 4;

            for col in 0..32 {
                if (row_mask >> col) & 1 == 1 {
                    let gy = start_y + row;
                    let gx = start_x + col;
                    if gy < dimension && gx < dimension {
                        pixels[gy * dimension + gx] = 255;
                    }
                }
            }
        }
    }

    println!("Data consumed: {} / {} bytes", data_pos, chunk_data.len());

    // Write PNG
    let file = File::create(output_path)?;
    let w = BufWriter::new(file);

    let mut encoder = png::Encoder::new(w, dimension as u32, dimension as u32);
    encoder.set_color(png::ColorType::Grayscale);
    encoder.set_depth(png::BitDepth::Eight);
    encoder.set_compression(png::Compression::Default);

    let mut writer = encoder.write_header()?;
    writer.write_image_data(&pixels)?;

    println!("Saved to {}", output_path);
    Ok(())
}

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        eprintln!("Usage: grleconvert <input.grle> [output.png]");
        eprintln!("       grleconvert <input.gdm> [output.png]");
        std::process::exit(1);
    }

    let input_path = &args[1];
    let output_path = if args.len() > 2 {
        args[2].clone()
    } else {
        let path = Path::new(input_path);
        let stem = path.file_stem().unwrap().to_str().unwrap();
        format!("{}.png", stem)
    };

    let ext = Path::new(input_path)
        .extension()
        .and_then(|e| e.to_str())
        .unwrap_or("")
        .to_lowercase();

    let result = match ext.as_str() {
        "grle" => convert_grle(input_path, &output_path),
        "gdm" => convert_gdm(input_path, &output_path),
        _ => {
            eprintln!("Unknown file extension: {}", ext);
            std::process::exit(1);
        }
    };

    if let Err(e) = result {
        eprintln!("Error: {}", e);
        std::process::exit(1);
    }
}
